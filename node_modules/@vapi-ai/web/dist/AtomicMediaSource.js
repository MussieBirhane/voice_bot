"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = __importDefault(require("async"));
const events_1 = __importDefault(require("events"));
// ManagedMediaSource needed for iOS Safari
function getMediaSource() {
    if (window.ManagedMediaSource) {
        return new window.ManagedMediaSource();
    }
    if (window.MediaSource) {
        return new window.MediaSource();
    }
    return null;
}
class AtomicMediaSource extends events_1.default {
    constructor() {
        super();
        this.sourceBuffer = null;
        this.mediaSource = getMediaSource();
        this.operationsQueue = this.createOperationQueue();
        if (!this.mediaSource) {
            console.error("MediaSource is not supported in your browser.");
            // Display a message to the user, or handle this situation in another way
            return;
        }
        this.mediaSource.addEventListener("sourceopen", () => {
            this.mediaSource.duration = Number.POSITIVE_INFINITY;
            this.sourceBuffer = this.mediaSource.addSourceBuffer('audio/webm; codecs="opus"');
            if (this.sourceBuffer) {
                this.sourceBuffer.mode = "sequence";
            }
        });
    }
    appendBuffer(buffer) {
        this.operationsQueue.push(() => {
            return new Promise((resolve, reject) => {
                if (this.sourceBuffer) {
                    this.sourceBuffer.addEventListener("updateend", () => {
                        resolve();
                    }, { once: true });
                    this.sourceBuffer.appendBuffer(buffer);
                }
                else {
                    reject();
                }
            });
        });
    }
    clearBuffer() {
        // this.operationsQueue.push(() => {
        //   return new Promise((resolve, reject) => {
        //     if (this.sourceBuffer) {
        //       this.sourceBuffer.addEventListener(
        //         "updateend",
        //         () => {
        //           resolve();
        //         },
        //         { once: true }
        //       );
        //       if (this.sourceBuffer.buffered.length > 0) {
        //         this.sourceBuffer.remove(0, this.sourceBuffer.buffered.end(0));
        //       }
        //     } else {
        //       reject();
        //     }
        //   });
        // });
    }
    createOperationQueue() {
        return async_1.default.queue((task, callback) => {
            task().then(() => callback());
        }, 1);
    }
}
exports.default = AtomicMediaSource;
